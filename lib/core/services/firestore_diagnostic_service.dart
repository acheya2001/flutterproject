import 'package:flutter/foundation.dart';import 'package:cloud_firestore/cloud_firestore.dart';import ';  static Future<Map<String, dynamic>> performFullDiagnostic(';    debugPrint('[FIRESTORE_DIAGNOSTIC] üîç Debut diagnostic complet...';      'timestamp: DateTime.now().toIso8601String(';      'tests';      'recommendations';      'overall_status': ';    _analyzeResults(results';    debugPrint(';  static Future<void> _testInternetConnectivity(Map<String, dynamic> results';      debugPrint(';      final connectivityResult = await Connectivity().checkConnectivity(';      results['tests']['internet';        'status': hasConnection ? 'success' : 'failed';        'connection_type: connectivityResult.toString(';        'message': hasConnection ? 'Connexion Internet OK' : ';      if (!hasConnection';        results['recommendations'].add(';    } catch (e';      results['tests']['internet';        'status': 'error';        'error: e.toString(';        'message': ';  static Future<void> _testFirebaseAuth(Map<String, dynamic> results';      debugPrint('[FIRESTORE_DIAGNOSTIC] üîê Test authentification Firebase...';      results['tests']['auth';        'status': isAuthenticated ? 'success' : 'warning';        'user_id';        'email';        'message': isAuthenticated ? 'Utilisateur authentifie' : 'Pas d\';      if (!isAuthenticated';        results['recommendations'].add(';    } catch (e';      results['tests']['auth';        'status': 'error';        'error: e.toString(';        'message': ';  static Future<void> _testFirestoreConfig(Map<String, dynamic> results';      debugPrint('[FIRESTORE_DIAGNOSTIC] ‚öôÔ∏è Test configuration Firestore...';      results['tests']['config';        'status': 'success';        'host';        'ssl_enabled';        'persistence_enabled';        'message': ';    } catch (e';      results['tests']['config';        'status': 'error';        'error: e.toString(';        'message': 'Erreur configuration Firestore';      results['recommendations'].add(';  static Future<void> _testSecurityRules(Map<String, dynamic> results';      debugPrint('[FIRESTORE_DIAGNOSTIC] üõ°Ô∏è Test regles de securite...';          .collection('test_public';          .doc(';          .timeout(const Duration(seconds: 3)';      results['tests']['security';        'status': 'success';        'can_read';        'message': ';      final isPermissionError = e.toString(').contains('permission-denied';      results['tests']['security';        'status': isPermissionError ? 'warning' : 'error';        'can_read';        'error: e.toString(';        'message';            ? 'Regles de securite restrictives';            : ';      if (isPermissionError';        results['recommendations'].add(';  static Future<void> _testBasicOperations(Map<String, dynamic> results';      debugPrint(';      final startTime = DateTime.now(';            .collection('health_check';            .doc(';        final readTime = DateTime.now().difference(startTime';        results['tests']['read';          'status': 'success';          'latency_ms';          'message': ';      } catch (e';        results['tests']['read';          'status': 'failed';          'error: e.toString(';          'message': ';        final writeStartTime = DateTime.now(';            .collection('health_check';            .doc('test_write';          'test';          'timestamp: FieldValue.serverTimestamp(';          ';        final writeTime = DateTime.now().difference(writeStartTime';        results['tests']['write';          'status': 'success';          'latency_ms';          'message': ';      } catch (e';        results['tests']['write';          'status': 'failed';          'error: e.toString(';          'message': ';    } catch (e';      results['tests']['basic_ops';        'status': 'error';        'error: e.toString(';        'message': ';  static Future<void> _testNetworkLatency(Map<String, dynamic> results';      debugPrint(';        final startTime = DateTime.now(';              .collection('ping_test';              .doc(';        final avgLatency = latencies.reduce((a, b) => a + b';        results['tests']['latency';          'status': avgLatency < 1000 ? 'success' : 'warning';          'average_ms: avgLatency.round(';          'min_ms: latencies.reduce((a, b) => a < b ? a : b';          'max_ms: latencies.reduce((a, b) => a > b ? a : b';          'message': 'Latence reseau: {avgLatency.round(')}ms';          results['recommendations'].add('üêå Latence elevee - Verifier la connexion';        results['tests']['latency';          'status': 'failed';          'message': ';    } catch (e';      results['tests']['latency';        'status': 'error';        'error: e.toString(';        'message': ';  static void _analyzeResults(Map<String, dynamic> results';    final tests = results['tests';    final recommendations = results[';    tests.forEach((testName, result';      if (result['status'] == ';    if (successCount == totalTests';      results['overall_status'] = 'healthy';      recommendations.add(';    } else if (successCount >= totalTests * 0.7';      results['overall_status'] = 'degraded';      recommendations.add('‚ö†Ô∏è Firestore fonctionne partiellement';      results['overall_status'] = 'unhealthy';      recommendations.add('‚ùå Problemes majeurs avec Firestore';    if (tests['internet']?['status'] != 'success';      recommendations.add('üîß Redemarrer la connexion Internet';    if (tests['auth']?['status'] != 'success';      recommendations.add('üîß Se reconnecter a Firebase Auth';    if (tests['read']?['status'] != 'success' || tests['write']?['status'] != 'success';      recommendations.add('üîß Verifier les regles Firestore et les permissions';    final avgLatency = tests['latency']?[';    if (avgLatency != null && avgLatency > 1000';      recommendations.add(';  static Future<bool> isFirestoreAvailable(';          .collection('health_check';          .doc(';    } catch (e';      debugPrint(';    final buffer = StringBuffer(';    buffer.writeln('üîç DIAGNOSTIC FIRESTORE';    buffer.writeln('= * 40';    buffer.writeln('üìÖ '{diagnostic['timestamp']}';    buffer.writeln('üéØ Statut: '{diagnostic['overall_status';    buffer.writeln(';    buffer.writeln('üìä TESTS:';    final tests = diagnostic[';    tests.forEach((testName, result';      final status = result['status'] == 'success' ? '‚úÖ';                    result['status'] == 'warning' ? '‚ö†Ô∏è' : '‚ùå';      buffer.writeln('  $status $testName: '{result['message';    buffer.writeln(';    buffer.writeln('üí° RECOMMANDATIONS:';    final recommendations = diagnostic[';    for (final rec in recommendations';      buffer.writeln('  ‚Ä¢ ';