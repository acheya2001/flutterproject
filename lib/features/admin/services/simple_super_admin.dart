import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import '../../../core/services/firebase_service.dart';
import '../../../core/constants/app_constants.dart';

/// üîê Mode Super Admin Global
class SuperAdminMode {
  static bool _isActive = false;

  static bool get isActive => _isActive;

  static void activate() {
    _isActive = true;
    debugPrint('[SUPER_ADMIN_MODE] üîê Mode Super Admin ACTIV√â');
  }

  static void deactivate() {
    _isActive = false;
    debugPrint('[SUPER_ADMIN_MODE] üîì Mode Super Admin D√âSACTIV√â');
  }
}

/// üîê Service Super Admin Simplifi√© (sans UserModel)
class SimpleSuperAdmin {
  static final FirebaseAuth _auth = FirebaseService.auth;
  static final FirebaseFirestore _firestore = FirebaseService.firestore;

  /// üìß Informations du Super Admin
  static const String SUPER_ADMIN_EMAIL = 'constat.tunisie.app@gmail.com';
  static const String SUPER_ADMIN_PASSWORD = 'Acheya123';

  /// üÜï Cr√©er le Super Admin avec structure simple
  static Future<void> createSuperAdmin() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üîê V√©rification du Super Admin...');

      // Essayer de se connecter pour v√©rifier si le compte existe
      try {
        final userCredential = await _auth.signInWithEmailAndPassword(
          email: SUPER_ADMIN_EMAIL,
          password: SUPER_ADMIN_PASSWORD,
        );

        debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Super Admin existe d√©j√† et fonctionne !');
        debugPrint('[SIMPLE_SUPER_ADMIN] üÜî UID: ${userCredential.user!.uid}');
        debugPrint('[SIMPLE_SUPER_ADMIN] üìß Email: $SUPER_ADMIN_EMAIL');

        await _auth.signOut(); // Se d√©connecter imm√©diatement
        return;

      } catch (e) {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚ö†Ô∏è Compte n\'existe pas, cr√©ation...');

        // Cr√©er le compte seulement s'il n'existe pas
        try {
          final userCredential = await _auth.createUserWithEmailAndPassword(
            email: SUPER_ADMIN_EMAIL,
            password: SUPER_ADMIN_PASSWORD,
          );

          debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Nouveau Super Admin cr√©√© !');
          debugPrint('[SIMPLE_SUPER_ADMIN] üÜî UID: ${userCredential.user!.uid}');

          await _auth.signOut(); // Se d√©connecter imm√©diatement

        } catch (createError) {
          debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur cr√©ation: $createError');
          // Si l'erreur est "email-already-in-use", c'est OK
          if (createError.toString().contains('email-already-in-use')) {
            debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Compte existe d√©j√† (normal)');
            return;
          }
          rethrow;
        }
      }

    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur lors de la cr√©ation: $e');
      rethrow;
    }
  }

  /// üßπ Nettoyer l'√©tat Firebase Auth
  static Future<void> cleanFirebaseAuthState() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üßπ Nettoyage √©tat Firebase Auth...');

      // Se d√©connecter compl√®tement
      await _auth.signOut();

      // Attendre que l'√©tat soit nettoy√©
      await Future.delayed(const Duration(milliseconds: 500));

      debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ √âtat Firebase Auth nettoy√©');
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ö†Ô∏è Erreur nettoyage: $e');
    }
  }

  /// üîê Connexion Super Admin avec Nettoyage
  static Future<UserCredential?> signInSuperAdmin({
    String? email,
    String? password,
  }) async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üîê === D√âBUT CONNEXION ===');
      debugPrint('[SIMPLE_SUPER_ADMIN] üìß Email: ${email ?? SUPER_ADMIN_EMAIL}');
      debugPrint('[SIMPLE_SUPER_ADMIN] üîë Password: ${password != null ? '***' : 'DEFAULT'}');

      // NETTOYER L'√âTAT FIREBASE AUTH D'ABORD
      await cleanFirebaseAuthState();

      // ACTIVER LE MODE SUPER ADMIN AVANT LA CONNEXION
      SuperAdminMode.activate();

      debugPrint('[SIMPLE_SUPER_ADMIN] üî• Appel Firebase Auth...');

      // Essayer avec un d√©lai pour √©viter les probl√®mes de timing
      await Future.delayed(const Duration(milliseconds: 100));

      final userCredential = await _auth.signInWithEmailAndPassword(
        email: email ?? SUPER_ADMIN_EMAIL,
        password: password ?? SUPER_ADMIN_PASSWORD,
      );

      debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Firebase Auth r√©ussi !');
      debugPrint('[SIMPLE_SUPER_ADMIN] üÜî UID: ${userCredential.user!.uid}');
      debugPrint('[SIMPLE_SUPER_ADMIN] üìß Email: ${userCredential.user!.email}');
      debugPrint('[SIMPLE_SUPER_ADMIN] üïê Cr√©√©: ${userCredential.user!.metadata.creationTime}');

      debugPrint('[SIMPLE_SUPER_ADMIN] üéØ Retour UserCredential...');
      return userCredential;

    } catch (e, stackTrace) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå ERREUR D√âTAILL√âE: $e');
      debugPrint('[SIMPLE_SUPER_ADMIN] üìç STACK TRACE: $stackTrace');
      SuperAdminMode.deactivate(); // D√©sactiver en cas d'erreur

      // Si c'est l'erreur PigeonUserDetails, essayer une approche alternative
      if (e.toString().contains('PigeonUserDetails')) {
        debugPrint('[SIMPLE_SUPER_ADMIN] üîÑ Tentative de r√©cup√©ration...');
        return await _attemptRecovery(email, password);
      }

      rethrow;
    }
  }

  /// üîÑ Tentative de r√©cup√©ration apr√®s erreur PigeonUserDetails
  static Future<UserCredential?> _attemptRecovery(String? email, String? password) async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üîÑ === TENTATIVE DE R√âCUP√âRATION ===');

      // Attendre plus longtemps
      await Future.delayed(const Duration(seconds: 2));

      // V√©rifier si l'utilisateur est d√©j√† connect√©
      final currentUser = _auth.currentUser;
      if (currentUser != null && currentUser.email == (email ?? SUPER_ADMIN_EMAIL)) {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Utilisateur d√©j√† connect√© apr√®s erreur');

        // Retourner null et g√©rer dans le provider
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚ö†Ô∏è Impossible de cr√©er UserCredential, mais utilisateur connect√©');
        return null;
      }

      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå R√©cup√©ration √©chou√©e');
      return null;

    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur r√©cup√©ration: $e');
      return null;
    }
  }

  /// üìä Obtenir les informations du Super Admin (format simple)
  static Future<Map<String, dynamic>?> getSuperAdminInfo() async {
    try {
      // Retourner des donn√©es statiques pour √©viter les probl√®mes de s√©rialisation
      final user = _auth.currentUser;

      if (user != null && user.email == SUPER_ADMIN_EMAIL) {
        return {
          'id': user.uid,
          'email': SUPER_ADMIN_EMAIL,
          'firstName': 'Super',
          'lastName': 'Admin',
          'phone': '+216 70 000 000',
          'role': 'super_admin',
          'status': 'active',
          'createdBy': 'SYSTEM',
          'cin': 'SUPER_ADMIN',
          'address': 'Tunis, Tunisie',
        };
      }
      return null;
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] Erreur lors de la r√©cup√©ration: $e');
      return null;
    }
  }

  /// üîç V√©rifier si un utilisateur est Super Admin (simplifi√©)
  static Future<bool> isSuperAdmin(String userId) async {
    try {
      final user = _auth.currentUser;
      // V√©rification simple bas√©e sur l'email
      return user != null && user.email == SUPER_ADMIN_EMAIL && user.uid == userId;
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] Erreur lors de la v√©rification: $e');
      return false;
    }
  }

  /// üßπ Supprimer tous les Super Admins existants
  static Future<void> deleteAllSuperAdmins() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üóëÔ∏è Suppression des Super Admins...');

      final snapshot = await _firestore
          .collection(AppConstants.usersCollection)
          .where('role', isEqualTo: 'super_admin')
          .get();

      for (final doc in snapshot.docs) {
        await doc.reference.delete();
        debugPrint('[SIMPLE_SUPER_ADMIN] üóëÔ∏è Supprim√©: ${doc.id}');
      }

      debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ ${snapshot.docs.length} Super Admin(s) supprim√©(s)');
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur lors de la suppression: $e');
    }
  }

  /// üßπ Nettoyer le compte existant
  static Future<void> cleanExistingAccount() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üßπ Nettoyage du compte existant...');

      // Se connecter pour supprimer le compte
      try {
        final userCredential = await _auth.signInWithEmailAndPassword(
          email: SUPER_ADMIN_EMAIL,
          password: SUPER_ADMIN_PASSWORD,
        );

        // Supprimer le document Firestore
        await _firestore
            .collection(AppConstants.usersCollection)
            .doc(userCredential.user!.uid)
            .delete();

        // Supprimer le compte Auth
        await userCredential.user!.delete();

        debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Compte existant supprim√©');
      } catch (e) {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚ö†Ô∏è Pas de compte existant √† supprimer: $e');
      }

    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur lors du nettoyage: $e');
    }
  }

  /// üîÑ Reset complet : supprimer et recr√©er
  static Future<void> resetSuperAdmin() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üîÑ Reset complet du Super Admin...');

      // 1. Nettoyer le compte existant
      await cleanExistingAccount();

      // 2. Attendre un peu
      await Future.delayed(const Duration(seconds: 1));

      // 3. Cr√©er un nouveau Super Admin
      await createSuperAdmin();

      debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Reset termin√© !');
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur lors du reset: $e');
      rethrow;
    }
  }

  /// üß™ Tester la connexion
  static Future<void> testConnection() async {
    try {
      debugPrint('[SIMPLE_SUPER_ADMIN] üß™ Test de connexion...');

      final userCredential = await signInSuperAdmin();
      
      if (userCredential != null) {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Test r√©ussi !');
        await _auth.signOut();
      }
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Test √©chou√©: $e');
    }
  }

  /// üìã Afficher les informations
  static Future<void> showInfo() async {
    try {
      final info = await getSuperAdminInfo();
      
      if (info != null) {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚úÖ Super Admin trouv√©:');
        debugPrint('[SIMPLE_SUPER_ADMIN] üìß Email: ${info['email']}');
        debugPrint('[SIMPLE_SUPER_ADMIN] üë§ Nom: ${info['firstName']} ${info['lastName']}');
        debugPrint('[SIMPLE_SUPER_ADMIN] üÜî ID: ${info['id']}');
        debugPrint('[SIMPLE_SUPER_ADMIN] üé≠ R√¥le: ${info['role']}');
      } else {
        debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Aucun Super Admin trouv√©');
      }
    } catch (e) {
      debugPrint('[SIMPLE_SUPER_ADMIN] ‚ùå Erreur: $e');
    }
  }
}
